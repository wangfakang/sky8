{"name":"Sky8","tagline":"nginx least_conn load balancing algorithm ","body":"`nginx least_conn　算法的解析`\r\n\r\n在之前的[文章](http://wangfakang.github.io/sky6)讲解了nginx的round_robin.ip_hash.constent_hash的负载均衡算法，\r\n再后面的学习上接触到了least_conn今天抽时间补上，,该模块就是每次选择最少连接负载均衡算法，简单来说就是每次选择\r\n的都是当前最少连接的一个server(这个最少连接不是全局的，是每个进程都有自己的一个统计列表)。　\r\n\r\n看了这么多饿负载均衡算法，不知道你有什么体会（发现了没有?有很多的负载均衡都会去复用round_robin算法），\r\n是的优秀饿设计，的确很佩服．　　　\r\n\r\n\r\n首先来看如何打开least_conn模块:    \r\n    \r\n``` c    \r\nstatic ngx_command_t  ngx_http_upstream_least_conn_commands[] = {\r\n \r\n    { ngx_string(\"least_conn\"),\r\n      NGX_HTTP_UPS_CONF|NGX_CONF_NOARGS,\r\n      ngx_http_upstream_least_conn,\r\n      0,\r\n      0,\r\n      NULL },\r\n \r\n      ngx_null_command\r\n};\r\n```\r\n\r\n可以看到命令很简单，就是在upstream块里面加上 least_conn就行了。   \r\n  \r\n来看命令对应的回调，least_conn的入口就是在这个里面设置的.\r\n\r\n```c\r\nstatic char *\r\nngx_http_upstream_least_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\r\n{\r\n    ngx_http_upstream_srv_conf_t  *uscf;\r\n \r\n    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);\r\n \r\n    uscf->peer.init_upstream = ngx_http_upstream_init_least_conn;\r\n \r\n    uscf->flags = NGX_HTTP_UPSTREAM_CREATE\r\n                  |NGX_HTTP_UPSTREAM_WEIGHT\r\n                  |NGX_HTTP_UPSTREAM_MAX_FAILS\r\n                  |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT\r\n                  |NGX_HTTP_UPSTREAM_DOWN\r\n                  |NGX_HTTP_UPSTREAM_BACKUP;\r\n \r\n    return NGX_CONF_OK;\r\n}\r\n```\r\n\r\n可以看到很简单，就是设置了peer.init_upstream,然后设置了支持的flags。那么这里就有问题了，\r\npeer.init_upstream什么时候会被调用呢。  \r\n\r\nupstream 进行相应饿初始化饿时候\r\n\r\n ```c\r\nstatic char *\r\nngx_http_upstream_init_main_conf(ngx_conf_t *cf, void *conf)\r\n{\r\n    ngx_http_upstream_main_conf_t  *umcf = conf;\r\n \r\n    ngx_uint_t                      i;\r\n    ngx_array_t                     headers_in;\r\n    ngx_hash_key_t                 *hk;\r\n    ngx_hash_init_t                 hash;\r\n    ngx_http_upstream_init_pt       init;\r\n    ngx_http_upstream_header_t     *header;\r\n    ngx_http_upstream_srv_conf_t  **uscfp;\r\n \r\n    uscfp = umcf->upstreams.elts;\r\n \r\n    for (i = 0; i < umcf->upstreams.nelts; i++) {\r\n//判断是否有设置 initupstream,默认是round robin算法.\r\n        init = uscfp[i]->peer.init_upstream ? uscfp[i]->peer.init_upstream:\r\n                                            ngx_http_upstream_init_round_robin;\r\n \r\n        if (init(cf, uscfp[i]) != NGX_OK) {\r\n            return NGX_CONF_ERROR;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n上面的代码可以看到是在解析upstream命令的时候，调用init_upstream的，因此也就可以这么说，init_upstream\r\n中初始化的的东西，每个进程都有自己的一份拷贝.（注意cow［写时拷贝技术］）\r\n\r\n所以我们来看ngx_http_upstream_init_least_conn，这个函数主要就是初始化round robin(主要是为了初始化权重\r\n等参数，而且least conn中如果多个server有相同的连接数，则会使用round robin算法)以及设置peer的init回调.\r\n\r\n还有一个要注意的就是conns数组［每个worker都有饿，不是全局饿］，这个数组每个slot保存了对应server的连接数\r\n\r\n```c\t\r\nngx_int_t\r\nngx_http_upstream_init_least_conn(ngx_conf_t *cf,\r\n    ngx_http_upstream_srv_conf_t *us)\r\n{\r\n    ngx_uint_t                            n;\r\n    ngx_http_upstream_rr_peers_t         *peers;\r\n    ngx_http_upstream_least_conn_conf_t  *lcf;\r\n \r\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf->log, 0,\r\n                   \"init least conn\");\r\n//初始化round robin\r\n    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {\r\n        return NGX_ERROR;\r\n    }\r\n \r\n    peers = us->peer.data;\r\n \r\n    n = peers->number;\r\n \r\n    if (peers->next) {\r\n        n += peers->next->number;\r\n    }\r\n \r\n    lcf = ngx_http_conf_upstream_srv_conf(us,\r\n                                          ngx_http_upstream_least_conn_module);\r\n//创建conns数组\r\n    lcf->conns = ngx_pcalloc(cf->pool, sizeof(ngx_uint_t) * n);\r\n    if (lcf->conns == NULL) {\r\n        return NGX_ERROR;\r\n    }\r\n//设置init\r\n    us->peer.init = ngx_http_upstream_init_least_conn_peer;\r\n \r\n    return NGX_OK;\r\n}\r\n\r\n而us->peer.init是在upstream的request初始化的时候调用的，也就是说每个request都会调用这个函数来初始化：\r\n\r\n\t\r\nstatic void\r\nngx_http_upstream_init_request(ngx_http_request_t *r)\r\n{\r\n\r\nfound:\r\n \r\n    if (uscf->peer.init(r, uscf) != NGX_OK) {\r\n        ngx_http_upstream_finalize_request(r, u,\r\n                                           NGX_HTTP_INTERNAL_SERVER_ERROR);\r\n        return;\r\n    }\r\n \r\n    ngx_http_upstream_connect(r, u);\r\n}\r\n\r\n然后我们就来看peer.init回调ngx_http_upstream_init_least_conn_peer，在这个函数中，主要是用来初始化对应的数据结构,\r\n然后挂载对应的回调(getpeer/freepeer).　　　\r\n\r\n\t\r\ntypedef struct {\r\n    /* the round robin data must be first */\r\n    ngx_http_upstream_rr_peer_data_t   rrp;\r\n//连接信息保存\r\n    ngx_uint_t                        *conns;\r\n//对应的get和free连接的回调\r\n    ngx_event_get_peer_pt              get_rr_peer;\r\n    ngx_event_free_peer_pt             free_rr_peer;\r\n} ngx_http_upstream_lc_peer_data_t;\r\n \r\nstatic ngx_int_t\r\nngx_http_upstream_init_least_conn_peer(ngx_http_request_t *r,\r\n    ngx_http_upstream_srv_conf_t *us)\r\n{\r\n    ngx_http_upstream_lc_peer_data_t     *lcp;\r\n    ngx_http_upstream_least_conn_conf_t  *lcf;\r\n \r\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\r\n                   \"init least conn peer\");\r\n \r\n    lcf = ngx_http_conf_upstream_srv_conf(us,\r\n                                          ngx_http_upstream_least_conn_module);\r\n \r\n    lcp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_lc_peer_data_t));\r\n    if (lcp == NULL) {\r\n        return NGX_ERROR;\r\n    }\r\n \r\n    lcp->conns = lcf->conns;\r\n \r\n    r->upstream->peer.data = &lcp->rrp;\r\n//初始化round robin\r\n    if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) {\r\n        return NGX_ERROR;\r\n    }\r\n//设置回调\r\n    r->upstream->peer.get = ngx_http_upstream_get_least_conn_peer;\r\n    r->upstream->peer.free = ngx_http_upstream_free_least_conn_peer;\r\n \r\n    lcp->get_rr_peer = ngx_http_upstream_get_round_robin_peer;\r\n    lcp->free_rr_peer = ngx_http_upstream_free_round_robin_peer;\r\n \r\n    return NGX_OK;\r\n}\r\n```\r\n\r\n上面可以看到每个lcp都有自己的get peer和free回调，这是什么原因呢，和upstream->peer的get和free的区别在哪里，\r\n这个是这样的原因，主要是least conn算法中，如果多个server都有相同的连接数，那么就需要使用round robin算法了，\r\n所以就保存了round robin的peer回调。　　　\r\n\r\n然后来看对应的peer get回调在那里调用的，首先通过前面的blog 我们知道每次当要和upstream建立连接的时候，\r\n我们都需要调用ngx_event_connect_peer，最终这个函数会创建连接，然后再去connect upstream，而我们的get\r\n回调也就是在这个函数中调用的。　　　　\r\n\r\n```c\t\r\nngx_int_t\r\nngx_event_connect_peer(ngx_peer_connection_t *pc)\r\n{\r\n    int                rc;\r\n    ngx_int_t          event;\r\n    ngx_err_t          err;\r\n    ngx_uint_t         level;\r\n    ngx_socket_t       s;\r\n    ngx_event_t       *rev, *wev;\r\n    ngx_connection_t  *c;\r\n//调用get\r\n    rc = pc->get(pc, pc->data);\r\n    if (rc != NGX_OK) {\r\n        return rc;\r\n    }\r\n\r\n}\r\n```\r\n其实nginx的load balance模块中，最核心的就是peer.get回调了，基本上核心的算法都在get回调里面实现，所以我们来\r\n看ngx_http_upstream_get_least_conn_peer,首先是选择最少连接的server，这里要注意，其实不仅仅是最少连接，还要\r\n加上权重，这里nginx使用的是连接数和权重的乘积。［其实这里使用了一个交叉相乘的公式进行比较］\r\n\r\n还有一个要注意的，就是对于每一个请求，Nginx保存了一个位图，这个位图保存了所有server是否已经被当前request\r\n使用过的状态，如果使用过则对应的位是1，否则为0，这个主要是为了处理失败的情况，而重复进行连接。\r\n\r\n```c\r\n\t\r\n    for (i = 0; i < peers->number; i++) {\r\n//一个字节8位，所以计算当前peer所处的位置\r\n        n = i / (8 * sizeof(uintptr_t));\r\n//得到当前peer的状态\r\n        m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));\r\n//如果已经服务过，则跳过\r\n        if (lcp->rrp.tried[n] & m) {\r\n            continue;\r\n        }\r\n \r\n        peer = &peers->peer[i];\r\n \r\n        if (peer->down) {\r\n            continue;\r\n        }\r\n//如果超过最大失败次数，并且还没超时，则跳过.\r\n        if (peer->max_fails\r\n            && peer->fails >= peer->max_fails\r\n            && now - peer->checked <= peer->fail_timeout)\r\n        {\r\n            continue;\r\n        }\r\n \r\n        /*\r\n         * select peer with least number of connections; if there are\r\n         * multiple peers with the same number of connections, select\r\n         * based on round-robin\r\n         */\r\n//选择server\r\n        if (best == NULL\r\n            || lcp->conns[i] * best->weight < lcp->conns[p] * peer->weight)\r\n        {\r\n            best = peer;\r\n//many表示是否有多个server满足条件.\r\n            many = 0;\r\n//p为best的位置\r\n            p = i;\r\n \r\n        } else if (lcp->conns[i] * best->weight\r\n                   == lcp->conns[p] * peer->weight)\r\n        {\r\n//相等则说明有多个server满足条件.\r\n            many = 1;\r\n        }\r\n    }\r\n\r\n接下来这段就是当有多个server满足条件的时候的处理，这里是如果多个server满足条件，则进入round robin的处理逻辑。\r\n下面的代码和round robin的get peer回调中算法是一模一样的。就是根据权重选择一个合适的server，这里Nginx还调整过\r\nround robin算法．\r\n\r\n\r\n\t\r\nif (many) {\r\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc->log, 0,\r\n                   \"get least conn peer, many\");\r\n \r\n    for (i = p; i < peers->number; i++) {\r\n \r\n        n = i / (8 * sizeof(uintptr_t));\r\n        m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));\r\n \r\n        if (lcp->rrp.tried[n] & m) {\r\n            continue;\r\n        }\r\n \r\n        peer = &peers->peer[i];\r\n \r\n        if (peer->down) {\r\n            continue;\r\n        }\r\n \r\n        if (lcp->conns[i] * best->weight != lcp->conns[p] * peer->weight) {\r\n            continue;\r\n        }\r\n \r\n        if (peer->max_fails\r\n            && peer->fails >= peer->max_fails\r\n            && now - peer->checked <= peer->fail_timeout)\r\n        {\r\n            continue;\r\n        }\r\n \r\n        peer->current_weight += peer->effective_weight;\r\n        total += peer->effective_weight;\r\n \r\n        if (peer->effective_weight < peer->weight) {\r\n            peer->effective_weight++;\r\n        }\r\n \r\n        if (peer->current_weight > best->current_weight) {\r\n            best = peer;\r\n            p = i;\r\n        }\r\n    }\r\n}\r\n \r\nbest->current_weight -= total;\r\nbest->checked = now;\r\n```\r\n最后就是更新一些状态位，比如更新server的连接数 等　　\r\n\r\n最后回顾下：　　\r\n (1).该模块其实就是每次选择连接数最少(当然还和自己当前的权值相关,其实是当前连接数除以自己的权重的值作比较,\r\n 看谁小就选择谁.但是权值有可能是 0,所以做了等价对换,即交叉相乘)的server,其中有一个全局的conns数组用于记录\r\n 每个server的连接 数.　　　　　　\r\n (2).还有就是一种情况,当出现了多个server都满足条件的时候,则此时采用round_robin.　　　　　　　\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"nginx least_conn load balancing algorithm ","note":"Don't delete this file! It's used internally to help with page regeneration."}